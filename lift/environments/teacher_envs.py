from typing import Sequence
import torch
from tensordict import TensorDict, TensorDictBase
from torchrl.envs import Transform
from torchrl.envs import Compose

import gymnasium as gym
import numpy as np

from lift.environments.gym_envs import NpGymEnv, resize_gym_box_space


class TeacherEnv(gym.Wrapper):
    """Environment used to meta train teacher

    - Observations: game observation corrupted by emg policy
    - Actions: game actions generated by teacher

    Args:
        noise_range (list[float]): range of noise applied to corrupt teacher actions
        alpha_range (list[float]): range of entropy coefficient
    """
    def __init__(self, env: NpGymEnv, noise_range: list[float] = [0.001, 1.], alpha_range: list[float] = [0.001, 1.]):
        super().__init__(env)
        self.noise_range = noise_range
        self.alpha_range = alpha_range

        # add meta variables to observation space
        new_obs_dim = self.observation_space["observation"].shape[-1] + 2
        self.observation_space["observation"] = resize_gym_box_space(
            self.observation_space["observation"], new_obs_dim
        )

    def reset(self):
        obs = self.env.reset()

        # sample meta vars
        noise = np.random.uniform(self.noise_range[0], self.noise_range[1])
        alpha = np.random.uniform(self.alpha_range[0], self.alpha_range[1])
        self.meta_vars = np.array([noise, alpha], dtype=self.observation_space["observation"].dtype)
        
        obs["observation"] = np.concatenate([obs["observation"], self.meta_vars])
        return obs

    def step(self, action: np.ndarray):
        eps = np.random.normal(size=action.shape) * self.meta_vars[0]
        decoded_action = action + eps
        obs, rwd, done, info = self.env.step(decoded_action)

        obs["observation"] = np.concatenate([obs["observation"], self.meta_vars])
        return obs, rwd, done, info


class TeacherTransform(Transform):
    """Transforms observation to add meta teacher variables

    Args:
        noise_range (list[float]): range of noise applied to corrupt teacher actions
        alpha_range (list[float]): range of entropy coefficient
    """
    def __init__(
        self,
        noise_range: list[float],
        alpha_range: list[float],
        in_keys: Sequence[str] | None = None,
        out_keys: Sequence[str] | None = None,
        in_keys_inv: Sequence[str] | None = None,
        out_keys_inv: Sequence[str] | None = None,
    ):
        super().__init__(in_keys, out_keys, in_keys_inv, out_keys_inv)
        self.noise_range = noise_range
        self.alpha_range = alpha_range
        
    def _apply_transform(self, obs: torch.Tensor) -> None:
        new_obs = torch.cat([obs, self.meta_vars], dim=-1)
        return new_obs
    
    def _step(self, tensordict: TensorDictBase, next_tensordict: TensorDictBase) -> TensorDictBase:
        next_tensordict["observation"] = self._apply_transform(next_tensordict["observation"])
        return next_tensordict
    
    def _reset(self, tensordict: TensorDictBase, tensordict_reset: TensorDictBase) -> TensorDictBase:
        noise = torch.rand(1).uniform_(self.noise_range[0], self.noise_range[1])
        alpha = torch.rand(1).uniform_(self.alpha_range[0], self.alpha_range[1])
        ones = torch.ones_like(tensordict_reset["observation"][..., :1])
        self.meta_vars = ones * torch.cat([noise, alpha], dim=-1)
        
        tensordict_reset["observation"] = torch.cat([tensordict_reset["observation"], self.meta_vars], dim=-1)
        return tensordict_reset
    
    def transform_observation_spec(self, observation_spec):
        new_obs_dim = list(observation_spec["observation"].shape)
        new_obs_dim[-1] += 2
        observation_spec["observation"].shape = torch.Size(new_obs_dim)
        return observation_spec


if __name__ == "__main__":
    from torchrl.envs import TransformedEnv
    from lift.rl.utils import gym_env_maker
    np.random.seed(0)
    torch.manual_seed(0)

    # test np env
    env = NpGymEnv("FetchReachDense-v2")
    noise_range = [0.001, 1.]
    alpha_range = [0.001, 1.]
    env = TeacherEnv(env, noise_range=noise_range, alpha_range=alpha_range)
    
    obs = env.reset()
    act = env.action_space.sample()
    next_obs, rwd, done, info = env.step(act)
    assert env.observation_space["observation"].shape == (18,)
    assert obs["observation"].shape == (18,)
    assert next_obs["observation"].shape == (18,)
    assert np.all(obs["observation"][-2:] == next_obs["observation"][-2:])

    # test torchrl transform
    env = gym_env_maker("FetchReachDense-v2")
    env = TransformedEnv(env, Compose(TeacherTransform(noise_range, alpha_range, in_keys=["observation"], out_keys=["observation"])))
    
    action = TensorDict({"action": torch.randn(3)})
    obs1 = env.reset().clone()
    next_obs1 = env.step(action).clone()
    obs2 = env.reset().clone()
    next_obs2 = env.step(action).clone()
    assert obs1["observation"].shape == (18,)
    assert next_obs1["next"]["observation"].shape == (18,)
    assert obs2["observation"].shape == (18,)
    assert next_obs2["next"]["observation"].shape == (18,)
    assert torch.all(obs1["observation"][..., -2:] == next_obs1["next"]["observation"][..., -2:]), "meta variables should be the same across steps"
    assert torch.all(obs2["observation"][..., -2:] == next_obs2["next"]["observation"][..., -2:]), "meta variables should be the same across steps"
    assert torch.all(obs1["observation"][..., -2:] != obs2["observation"][..., -2:]), "meta variables should be different across episodes"